<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Henzel Moras</title><link>https://henzelmoras.github.io/</link><description>Recent content on Henzel Moras</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 23 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://henzelmoras.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Search Results</title><link>https://henzelmoras.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://henzelmoras.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Grub</title><link>https://henzelmoras.github.io/posts/linux-sys-admin/operation-of-running-systems/grub/</link><pubDate>Fri, 23 Apr 2021 00:00:00 +0000</pubDate><guid>https://henzelmoras.github.io/posts/linux-sys-admin/operation-of-running-systems/grub/</guid><description>About Virtually, all x86-based Linux systems (outside the embedded sphere) today use GRUB (GRand Unified Bootloader) to handle the early phases of system startup. Other platforms may have other equivalents, such as ELILO used on EFI systems such as IA64 (Itanium), and Das U-BOOT used on many embedded configurations.
Some important features of GRUB are:
Alternative operating systems can be chosen at boot time. Alternative kernels and/or initial ramdisks can be chosen at boot time for a given operating system.</description></item><item><title>Boot Process</title><link>https://henzelmoras.github.io/posts/linux-sys-admin/operation-of-running-systems/boot-process/</link><pubDate>Thu, 22 Apr 2021 00:00:00 +0000</pubDate><guid>https://henzelmoras.github.io/posts/linux-sys-admin/operation-of-running-systems/boot-process/</guid><description>In this post we will take about the boot process of linux OS
Stages There are 4 Stages and they are:
The Firmware Phase (BIOS and UEFI integrity check) (POST)
The Bootloader Phase
The Kernel Phase (initialization)
Starting Systemd, the parent of all processes
Firmware Phase The firmware is the BIOS (Basic Input/Output System) or the UEFI (Unified Extensible Firmware Interface) code that is stored in flash memory on the mother board.</description></item><item><title>Lab Setup</title><link>https://henzelmoras.github.io/posts/linux-sys-admin/lab-setup/</link><pubDate>Wed, 21 Apr 2021 00:00:00 +0000</pubDate><guid>https://henzelmoras.github.io/posts/linux-sys-admin/lab-setup/</guid><description>This Post we will focus on building our lab to practice Sys-Admin Tasks.
There are multiple ways of setting up the lab with different distro&amp;rsquo;s.
Cloud (AWS,GCP etc) Free tier. Hypervisor (virtual box, Vmware etc) Vagrant (which would use an hypervisor but convenient for ready to use boxs) many more.
I will choose Hypervisor(Virtual Box) with my host OS as Kubuntu.
Download VirtualBox virtualbox-link
select the distribution of your choice and download it.</description></item><item><title>Encryption</title><link>https://henzelmoras.github.io/posts/linux-sys-admin/advanced-storage-managment/encryption/</link><pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate><guid>https://henzelmoras.github.io/posts/linux-sys-admin/advanced-storage-managment/encryption/</guid><description>Why Use Encryption? Encryption should be used wherever sensitive data is being stored and transmitted. Configuring and using block device level encryption provides one of the strongest protections against harm caused by loss or compromise of data contained in hard drives and other media.
Modern Linux distributions offer the choice of encrypting all or some of your disk partitions during installation. It is also straightforward to create and format encrypted partitions at a later time, but you cannot encrypt an already existing partition in place without a data copying operation.</description></item><item><title>Logical Volume Manager</title><link>https://henzelmoras.github.io/posts/linux-sys-admin/advanced-storage-managment/logical-volume-manager/</link><pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate><guid>https://henzelmoras.github.io/posts/linux-sys-admin/advanced-storage-managment/logical-volume-manager/</guid><description>About Logical Volume Manager One or more physical volumes (disk partitions) are grouped together into a volume group. Then, the volume group is subdivided into logical volumes, which mimic to the system nominal physical disk partitions and can be formatted to contain mountable filesystems.
Logical volumes are created by putting all the devices into a large pool of disk space (the volume group), and then allocating space from the pool to create a logical volume.</description></item><item><title>Quotas</title><link>https://henzelmoras.github.io/posts/linux-sys-admin/advanced-storage-managment/quotas/</link><pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate><guid>https://henzelmoras.github.io/posts/linux-sys-admin/advanced-storage-managment/quotas/</guid><description>Filesystem Quotas Linux can use and enforce quotas on filesystems. Disk quotas allow administrators to control the maximum space particular users (or groups) are allowed. Considerable flexibility is allowed and quotas can be assigned on a per filesystem basis. Protection is provided against a subset of users exhausting collective resources.
Utilities quotacheck quotacheck generates and updates quota accounting files.
quotaon quotaon enables quota accounting.
quotaoff quotaoff disables quota accounting.</description></item><item><title>RAID</title><link>https://henzelmoras.github.io/posts/linux-sys-admin/advanced-storage-managment/raid/</link><pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate><guid>https://henzelmoras.github.io/posts/linux-sys-admin/advanced-storage-managment/raid/</guid><description>About RAID Three essential features of RAID are:
mirroring: writing the same data to more than one disk striping: splitting of data to more than one disk parity: extra data is stored to allow problem detection and repair, yielding fault tolerance. Thus, use of RAID can improve both performance and reliability.
mdadm is used to create and manage RAID devices.
Once created, the array name, /dev/mdX, can be used just like any other device, such as /dev/sdb1.</description></item><item><title>swap</title><link>https://henzelmoras.github.io/posts/linux-sys-admin/advanced-storage-managment/swap/</link><pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate><guid>https://henzelmoras.github.io/posts/linux-sys-admin/advanced-storage-managment/swap/</guid><description>About Swap Linux employs a virtual memory system, in which the operating system can function as if it had more memory than it really does. This kind of memory overcommission functions in two ways:
Many programs do not actually use all the memory they are given permission to use. Sometimes, this is because child processes inherit a copy of the parent&amp;rsquo;s memory regions utilizing a COW (Copy On Write) technique, in which the child only obtains a unique copy (on a page-by-page basis) when there is a change.</description></item><item><title>Disk Partition</title><link>https://henzelmoras.github.io/posts/linux-sys-admin/basic-storage-management/disk-partition/</link><pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate><guid>https://henzelmoras.github.io/posts/linux-sys-admin/basic-storage-management/disk-partition/</guid><description>How to many utilities are available to partition disks , we will be using fdisk to make partitions on disk.
# list disks [s0x45ker--_(+_+)_--SysAdmin ~]$ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 21.3G 0 disk ├─sda1 8:1 0 1G 0 part /boot └─sda2 8:2 0 20.3G 0 part ├─cl-root 253:0 0 18.3G 0 lvm / └─cl-swap 253:1 0 2.1G 0 lvm [SWAP] sdb 8:16 0 2G 0 disk sr0 11:0 1 1024M 0 rom sr1 11:1 1 1024M 0 rom we will be using /dev/sdb in this tutorial</description></item><item><title>Disk Types</title><link>https://henzelmoras.github.io/posts/linux-sys-admin/basic-storage-management/disk-types/</link><pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate><guid>https://henzelmoras.github.io/posts/linux-sys-admin/basic-storage-management/disk-types/</guid><description>SATA (Serial Advanced Technology Attachment) SATA disks were designed to replace the old IDE drives. They offer a smaller cable size (7 pins), native hot swapping, and faster and more efficient data transfer. They are seen as SCSI devices.
SCSI (Small Computer Systems Interface) SCSI disks range from narrow (8 bit bus) to wide (16 bit bus), with a transfer rate between 5 MB per second (narrow, standard SCSI) and 160 MB per second (Ultra-Wide SCSI-3).</description></item><item><title>File As Disk</title><link>https://henzelmoras.github.io/posts/linux-sys-admin/basic-storage-management/file-as-disk/</link><pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate><guid>https://henzelmoras.github.io/posts/linux-sys-admin/basic-storage-management/file-as-disk/</guid><description>About we can create Diskpartition using a file as image we can achieve this using &amp;lsquo;dd&amp;rsquo; or &amp;lsquo;losetup&amp;rsquo;
Using: &amp;lsquo;dd&amp;rsquo; create a file full of zeros using dd
[s0x45ker--_(+_+)_--SysAdmin ~]$ dd if=/dev/zero of=imagefile bs=1M count=1024 #create a file full of zeros 1024+0 records in 1024+0 records out 1073741824 bytes (1.1 GB, 1.0 GiB) copied, 0.904085 s, 1.2 GB/s Format Filesystem Type next we must put a filesystem on it Note u can create different filesystem formats 'mkfs.</description></item><item><title>Interacting With Disks</title><link>https://henzelmoras.github.io/posts/linux-sys-admin/basic-storage-management/interacting-with-disks/</link><pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate><guid>https://henzelmoras.github.io/posts/linux-sys-admin/basic-storage-management/interacting-with-disks/</guid><description>Mount The mount program allows attaching at any point in the tree structure; umount allows detaching them.
The mount point is the directory where the filesystem is attached. It must exist before mount can use it; mkdir can be used to create an empty directory. If a pre-existing directory is used and it contains files prior to being used as a mount point, they will be hidden after mounting. These files are not deleted and will again be visible when the filesystem is unmounted.</description></item><item><title>Storage Overview</title><link>https://henzelmoras.github.io/posts/linux-sys-admin/basic-storage-management/storage-overview/</link><pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate><guid>https://henzelmoras.github.io/posts/linux-sys-admin/basic-storage-management/storage-overview/</guid><description>Disks Disks are divided into partitions. In geometrical terms, these consist of physically contiguous groups of sectors or cylinders. A partition is a physically contiguous region on the disk. There are two partitioning layouts in use:
MBR (Master Boot Record) GPT (GUID Partition Table). MBR dates back to the early days of MSDOS.
The disk partition table is contained within the disk&amp;rsquo;s Master Boot Record (MBR), and is the 64 bytes following the 446 byte boot record.</description></item><item><title>Why Disk Partition ?</title><link>https://henzelmoras.github.io/posts/linux-sys-admin/basic-storage-management/why-disk-partition/</link><pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate><guid>https://henzelmoras.github.io/posts/linux-sys-admin/basic-storage-management/why-disk-partition/</guid><description>Why Partition? There are multiple reasons as to why it makes sense to divide your system data into multiple partitions, including:
Separation of user and application data from operating system files Sharing between operating systems and/or machines Security enhancement by imposing different quotas and permissions for different system parts Size concerns; keeping variable and volatile storage isolated from stable Performance enhancement of putting most frequently used data on faster storage media Swap space can be isolated from data and also used for hibernation storage.</description></item><item><title>Backup Partition</title><link>https://henzelmoras.github.io/posts/linux-sys-admin/basic-storage-management/backup-partition/</link><pubDate>Fri, 16 Apr 2021 00:00:00 +0000</pubDate><guid>https://henzelmoras.github.io/posts/linux-sys-admin/basic-storage-management/backup-partition/</guid><description>Using dd for backup we can use dd or gfdisk
The dd program is very useful for making copies of raw disk space. A common joke with `dd' is that is stands for data destroyer, so it should be noted that it&amp;rsquo;s a very dangerous utility.
we will use one of the partition we created from earlier posts /dev/sdb1
**lets create a file within disk than backup the disk and delete the file and restore the disk**</description></item><item><title>Linux Virtual Filesystem</title><link>https://henzelmoras.github.io/posts/linux-sys-admin/linux-virtual-filesystem/</link><pubDate>Fri, 16 Apr 2021 00:00:00 +0000</pubDate><guid>https://henzelmoras.github.io/posts/linux-sys-admin/linux-virtual-filesystem/</guid><description>Application programs read and write files , rather than dealing with physical locations on the actual hardware on which files are stored. Filesystems create a usable format on physical partition.
Files and their names are an abstraction camouflaging the physical I/O layer.
A UNIX-like filesystem uses a tree hierarchy:
Directories contain files and/or other directories Every path or node is under the root directory. Multiple filesystems may be (and usually are) merged together into a single tree structure.</description></item><item><title>Search Results</title><link>https://henzelmoras.github.io/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://henzelmoras.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item></channel></rss>