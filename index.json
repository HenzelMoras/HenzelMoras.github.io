[{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://henzelmoras.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"Why Use Encryption? Encryption should be used wherever sensitive data is being stored and transmitted. Configuring and using block device level encryption provides one of the strongest protections against harm caused by loss or compromise of data contained in hard drives and other media.\nModern Linux distributions offer the choice of encrypting all or some of your disk partitions during installation. It is also straightforward to create and format encrypted partitions at a later time, but you cannot encrypt an already existing partition in place without a data copying operation.\nwe will be Using cryptsetup with LUKS format to encrypt our disks\nDisk Encryption ill be making use of /dev/sdb u can use whatever u like, disk or file doesnt matter\n[s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo fdisk /dev/sdb Welcome to fdisk (util-linux 2.32.1). Changes will remain in memory only, until you decide to write them. Be careful before using the write command. Device does not contain a recognized partition table. Created a new DOS disklabel with disk identifier 0x3733f8f1. Command (m for help): g Created a new GPT disklabel (GUID: 9B1F3DFC-4D80-944A-B31B-C131509954E1). Command (m for help): p Disk /dev/sdb: 10 GiB, 10737418240 bytes, 20971520 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: gpt Disk identifier: 9B1F3DFC-4D80-944A-B31B-C131509954E1 Command (m for help): n Partition number (1-128, default 1): First sector (2048-20971486, default 2048): Last sector, +sectors or +size{K,M,G,T,P} (2048-20971486, default 20971486): +500M Created a new partition 1 of type \u0026#39;Linux filesystem\u0026#39; and of size 500 MiB. Command (m for help): p Disk /dev/sdb: 10 GiB, 10737418240 bytes, 20971520 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: gpt Disk identifier: 9B1F3DFC-4D80-944A-B31B-C131509954E1 Device Start End Sectors Size Type /dev/sdb1 2048 1026047 1024000 500M Linux filesystem Command (m for help): w The partition table has been altered. Calling ioctl() to re-read partition table. Syncing disks. [s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo partprobe -s /dev/sda: msdos partitions 1 2 /dev/sdb: gpt partitions 1 1. Encrypt the Disk [s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo cryptsetup luksFormat /dev/sdb1 WARNING: Device /dev/sdb1 already contains a \u0026#39;gpt\u0026#39; partition signature. WARNING! ======== This will overwrite data on /dev/sdb1 irrevocably. Are you sure? (Type \u0026#39;yes\u0026#39; in capital letters): YES Enter passphrase for /dev/sdb1: Verify passphrase: 2. Create Open Block Device [s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo cryptsetup luksOpen /dev/sdb1 treasure-box Enter passphrase for /dev/sdb1: 3. Entry within /etc/crypttab to make available at boot\n[s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo nano /etc/crypttab GNU nano 2.9.8 /etc/crypttab treasure-box /dev/sdb1 place a file system on it\n[s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo mkfs.ext4 /dev/mapper/treasure-box mke2fs 1.45.6 (20-Mar-2020) Creating filesystem with 495616 1k blocks and 123952 inodes Filesystem UUID: d3784539-d5e9-4f52-86ba-026cef3c19d4 Superblock backups stored on blocks: 8193, 24577, 40961, 57345, 73729, 204801, 221185, 401409 Allocating group tables: done Writing inode tables: done Creating journal (8192 blocks): done Writing superblocks and filesystem accounting information: done 4. Entry /etc/fstab [s0x45ekr--_(+_+)_--Sysadmin ~]$ mkdir treasure [s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo nano /etc/fstab /dev/mapper/treasure-box /home/s0x45ker/treasure ext4 defaults 1 2 mount it\n[s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo mount -a reboot\n[s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo reboot now enter the password\ndone\nEncrypting Swap its the same except for few things lets begin\nwe will make use of swap created from last turtorial follow steps from the tut to recreate\n[s0x45ekr--_(+_+)_--Sysadmin ~]$ cat /proc/swaps Filename\tType\tSize\tUsedPriority /dev/dm-1 partition\t2166780\t95744-2 /home/s0x45ker/swapfile file\t1048572\t0\t-3 1. Turn off Swap [s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo swapoff swapfile 2. Encrypt Swap same steps as disk encryption\nâ€”cipher \nsudo cryptsetup luksFormat --cipher aes swapfile sudo cryptsetup luksOpen swapfile swapcrypt 3. Enable Swap [s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo swapon /dev/mapper/swapcrypt [s0x45ekr--_(+_+)_--Sysadmin ~]$ cat /proc/swaps Filename\tType\tSize\tUsedPriority /dev/dm-1 partition\t2166780\t171396\t-2 /dev/dm-3 partition\t1032188\t0\t-3 [s0x45ekr--_(+_+)_--Sysadmin ~]$ cat /proc/swaps Filename\tType\tSize\tUsedPriority /dev/dm-1 partition\t2166780\t171396\t-2 /dev/dm-3 partition\t1032188\t0\t-3 Restore default to go back to normal\n[s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo swapoff /dev/mapper/swapcrypt [s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo cryptsetup luksClose swapcrypt [s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo swapon -a [s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo mkswap swapfile mkswap: swapfile: warning: wiping old crypto_LUKS signature. mkswap: swapfile: warning: wiping old crypto_LUKS signature. Setting up swapspace version 1, size = 1024 MiB (1073737728 bytes) no label, UUID=0efcd69c-8350-4547-841b-8e4d36a34f75 [s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo nano /etc/fstab /home/s0x45ker/swapfile swap swap defaults 0 0s0x45ker s0x45ekr--_(+_+)_--Sysadmin ~]$ cat /proc/swaps Filename\tType\tSize\tUsed\tPriority /dev/dm-1 partition\t2166780\t174832\t-2 /home/s0x45ker/swapfile file\t1048572\t0\t-3 ","date":"April 18, 2021","hero":"/posts/linux-sys-admin/advanced-storage-managment/encryption/images/march.jpg","permalink":"https://henzelmoras.github.io/posts/linux-sys-admin/advanced-storage-managment/encryption/","summary":"Why Use Encryption? Encryption should be used wherever sensitive data is being stored and transmitted. Configuring and using block device level encryption provides one of the strongest protections against harm caused by loss or compromise of data contained in hard drives and other media.\nModern Linux distributions offer the choice of encrypting all or some of your disk partitions during installation. It is also straightforward to create and format encrypted partitions at a later time, but you cannot encrypt an already existing partition in place without a data copying operation.","tags":null,"title":"Encryption"},{"categories":null,"contents":"About Logical Volume Manager One or more physical volumes (disk partitions) are grouped together into a volume group. Then, the volume group is subdivided into logical volumes, which mimic to the system nominal physical disk partitions and can be formatted to contain mountable filesystems.\nLogical volumes are created by putting all the devices into a large pool of disk space (the volume group), and then allocating space from the pool to create a logical volume.\nLVM has better scalability than RAID: logical volumes can easily be resized; i.e., enlarged or shrunk, as needs require. If more space is needed, additional devices can be added to the logical volume at any time.\nLVM Components There are a number of command line utilities used to create and manipulate volume groups, whose name always start withÂ vg, including:\n vgcreate: Creates volume groups. vgextend: Adds to volume groups. vgreduce: Shrinks volume groups.  Utilities that manipulate what physical partitions enter or leave volume groups start withÂ pvÂ and include:\n pvcreate: Converts a partition to a physical volume. pvdisplay: Shows the physical volumes being used. pvmove: Moves the data from one physical volume within the volume group to others; this might be required if a disk or partition is being removed for some reason. It would then be followed by: pvremove: Remove a partition from a physical volume.  TypingÂ man lvmÂ will give a full list of LVM utilities.\nor\ncheck /sbin/\n/sbin/pv*\n[s0x45ker--_(+_+)_--SysAdmin ~]$ sudo ls -lf /sbin/pv* /sbin/pvchange\t/sbin/pvcreate\t/sbin/pvmove\t/sbin/pvresize /sbin/pvscan /sbin/pvck\t/sbin/pvdisplay /sbin/pvremove /sbin/pvs /sbin/vg*\n[s0x45ker--_(+_+)_--SysAdmin ~]$ sudo ls -lf /sbin/vg* /sbin/vgcfgbackup /sbin/vgcreate /sbin/vgimportclone /sbin/vgrename /sbin/vgcfgrestore /sbin/vgdisplay /sbin/vgmerge\t/sbin/vgs /sbin/vgchange\t/sbin/vgexport /sbin/vgmknodes\t/sbin/vgscan /sbin/vgck\t/sbin/vgextend /sbin/vgreduce\t/sbin/vgsplit /sbin/vgconvert /sbin/vgimport /sbin/vgremove /sbin/lv*\n[s0x45ker--_(+_+)_--SysAdmin ~]$ sudo ls -lf /sbin/lv* /sbin/lvchange\t/sbin/lvm\t/sbin/lvmsadc /sbin/lvresize /sbin/lvconvert /sbin/lvmconfig /sbin/lvmsar /sbin/lvs /sbin/lvcreate\t/sbin/lvmdiskscan /sbin/lvreduce /sbin/lvscan /sbin/lvdisplay /sbin/lvmdump\t/sbin/lvremove /sbin/lvextend\t/sbin/lvmpolld /sbin/lvrename Create LVM lets make use of /dev/sdb partitions\n[s0x45ker--_(+_+)_--SysAdmin ~]$ lsblk /dev/sdb NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sdb 8:16 0 2G 0 disk â”œâ”€sdb1 8:17 0 256M 0 part â”œâ”€sdb2 8:18 0 256M 0 part â””â”€sdb3 8:19 0 1.5G 0 part Create Physical Volumes lets create pv groups\n[s0x45ker--_(+_+)_--SysAdmin ~]$ sudo pvcreate /dev/sdb1 WARNING: ext4 signature detected on /dev/sdb1 at offset 1080. Wipe it? [y/n]: y Wiping ext4 signature on /dev/sdb1. Physical volume \u0026#34;/dev/sdb1\u0026#34; successfully created. [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo pvcreate /dev/sdb2 WARNING: ext4 signature detected on /dev/sdb2 at offset 1080. Wipe it? [y/n]: y Wiping ext4 signature on /dev/sdb2. Physical volume \u0026#34;/dev/sdb2\u0026#34; successfully created. [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo pvcreate /dev/sdb3 WARNING: ext4 signature detected on /dev/sdb3 at offset 1080. Wipe it? [y/n]: y Wiping ext4 signature on /dev/sdb3. Physical volume \u0026#34;/dev/sdb3\u0026#34; successfully created. Display PV lets display them\n[s0x45ker--_(+_+)_--SysAdmin ~]$ sudo pvdisplay --- Physical volume --- PV Name /dev/sda2 VG Name cl PV Size \u0026lt;20.32 GiB / not usable 0 Allocatable yes (but full) PE Size 4.00 MiB Total PE 5201 Free PE 0 Allocated PE 5201 PV UUID HkaGdc-0SM4-q58B-GLpF-yBKh-dluM-Zb7psU \u0026#34;/dev/sdb1\u0026#34; is a new physical volume of \u0026#34;256.00 MiB\u0026#34; --- NEW Physical volume --- PV Name /dev/sdb1 VG Name PV Size 256.00 MiB Allocatable NO PE Size 0 Total PE 0 Free PE 0 Allocated PE 0 PV UUID r4DxPp-DwXw-MTKV-0rgJ-wslR-WvXf-ddTp95 \u0026#34;/dev/sdb2\u0026#34; is a new physical volume of \u0026#34;256.00 MiB\u0026#34; --- NEW Physical volume --- PV Name /dev/sdb2 VG Name PV Size 256.00 MiB Allocatable NO PE Size 0 Total PE 0 Free PE 0 Allocated PE 0 PV UUID p1MmuS-FtMY-TSfc-QTs0-f5kQ-8H02-G2hAkM \u0026#34;/dev/sdb3\u0026#34; is a new physical volume of \u0026#34;\u0026lt;1.50 GiB\u0026#34; --- NEW Physical volume --- PV Name /dev/sdb3 VG Name PV Size \u0026lt;1.50 GiB Allocatable NO PE Size 0 Total PE 0 Free PE 0 Allocated PE 0 PV UUID Sg0adM-I34I-WdtH-FSBh-fv4E-6v0q-MfwpBh Create Volume Groups lets create vg groups\n[s0x45ker--_(+_+)_--SysAdmin ~]$ sudo vgcreate myvgName /dev/sdb1 /dev/sdb2 Volume group \u0026#34;myvgName\u0026#34; successfully created Display Volume Groups [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo vgdisplay --- Volume group --- VG Name myvgName System ID Format lvm2 Metadata Areas 2 Metadata Sequence No 2 VG Access read/write VG Status resizable MAX LV 0 Cur LV 1 Open LV 0 Max PV 0 Cur PV 2 Act PV 2 VG Size 504.00 MiB PE Size 4.00 MiB Total PE 126 Alloc PE / Size 125 / 500.00 MiB Free PE / Size 1 / 4.00 MiB VG UUID 22zcce-qKWO-LsZ4-NsIK-2LaG-BihC-PXpOu3 --- Volume group --- VG Name cl System ID Format lvm2 Metadata Areas 1 Metadata Sequence No 3 VG Access read/write VG Status resizable MAX LV 0 Cur LV 2 Open LV 2 Max PV 0 Cur PV 1 Act PV 1 VG Size \u0026lt;20.32 GiB PE Size 4.00 MiB Total PE 5201 Alloc PE / Size 5201 / \u0026lt;20.32 GiB Free PE / Size 0 / 0 VG UUID KE3I02-N1rq-Jt6O-EfGT-jFFc-thKG-Bu7w0V Create Logical Volumes [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo lvcreate -L 500M -n mylvmName myvgName Logical volume \u0026#34;mylvmName\u0026#34; created. Display Logical Volumes [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo lvdisplay --- Logical volume --- LV Path /dev/myvgName/mylvmName LV Name mylvmName VG Name myvgName LV UUID O3Tq2d-Ncn6-Ek56-ZJv5-l6pg-Cf25-4dcc4D LV Write Access read/write LV Creation host, time localhost.localdomain, 2021-04-17 12:50:40 +0530 LV Status available # open 0 LV Size 500.00 MiB Current LE 125 Segments 2 Allocation inherit Read ahead sectors auto - currently set to 8192 Block device 253:2 --- Logical volume --- LV Path /dev/cl/swap LV Name swap VG Name cl LV UUID U40evz-UBNH-NuhE-6vn9-yW96-cC2B-1xgZgW LV Write Access read/write LV Creation host, time localhost, 2020-11-12 19:37:26 +0530 LV Status available # open 2 LV Size \u0026lt;2.07 GiB Current LE 529 Segments 1 Allocation inherit Read ahead sectors auto - currently set to 8192 Block device 253:1 --- Logical volume --- LV Path /dev/cl/root LV Name root VG Name cl LV UUID pfO1zZ-tB1E-a0p1-SCa9-68nu-jwMc-vK316T LV Write Access read/write LV Creation host, time localhost, 2020-11-12 19:37:26 +0530 LV Status available # open 1 LV Size 18.25 GiB Current LE 4672 Segments 1 Allocation inherit Read ahead sectors auto - currently set to 8192 Block device 253:0 Put A Filesystem on LVM using mkfs\n[s0x45ker--_(+_+)_--SysAdmin ~]$ sudo mkfs.ext4 /dev/myvgName/mylvmName mke2fs 1.45.6 (20-Mar-2020) Creating filesystem with 512000 1k blocks and 128016 inodes Filesystem UUID: b8106acd-3151-408b-9c73-e2d1fdf8191e Superblock backups stored on blocks: 8193, 24577, 40961, 57345, 73729, 204801, 221185, 401409 Allocating group tables: done Writing inode tables: done Creating journal (8192 blocks): done Writing superblocks and filesystem accounting information: done Create Dir for Mount [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo mkdir /mylvmpnt Mount Filesystem [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo mount /dev/myvgName/mylvmName /mylvmpnt Check Filesystem mount [s0x45ker--_(+_+)_--SysAdmin ~]$ df -Th | grep lvm /dev/mapper/myvgName-mylvmName ext4 477M 2.3M 445M 1% /mylvmpnt Make persistent Mount using fstab\n[s0x45ker--*(+*+)_--SysAdmin ~]$ sudo nano /etc/fstab\n# # /etc/fstab # Created by anaconda on Thu Nov 12 19:37:28 2020 # # Accessible filesystems, by reference, are maintained under \u0026#39;/dev/disk/\u0026#39;. # See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info. # # After editing this file, run \u0026#39;systemctl daemon-reload\u0026#39; to update systemd # units generated from this file. # /dev/mapper/cl-root / xfs defaults 0 0 UUID=03f520f5-2aec-411c-a15b-3e2f62ffc37c /boot ext4 defaults 1 2 /dev/mapper/cl-swap swap swap defaults 0 0 /dev/myvgName/mylvmName\t/mylvmpnt ext4 defaults 0 0 Extent LVM using lvresize\n[s0x45ker--_(+_+)_--SysAdmin ~]$ sudo lvresize -r -L +200M /dev/myvgName/mylvmName Insufficient free space: 50 extents needed, but only 1 available Extend Volume Group lets resize Volume Group\n[s0x45ker--_(+_+)_--SysAdmin ~]$ sudo vgextend myvgName /dev/sdb3 Volume group \u0026#34;myvgName\u0026#34; successfully extended display extended vg\n[s0x45ker--_(+_+)_--SysAdmin ~]$ sudo vgdisplay myvgName --- Volume group --- VG Name myvgName System ID Format lvm2 Metadata Areas 3 Metadata Sequence No 3 VG Access read/write VG Status resizable MAX LV 0 Cur LV 1 Open LV 1 Max PV 0 Cur PV 3 Act PV 3 VG Size \u0026lt;1.99 GiB PE Size 4.00 MiB Total PE 509 Alloc PE / Size 125 / 500.00 MiB Free PE / Size 384 / 1.50 GiB VG UUID 22zcce-qKWO-LsZ4-NsIK-2LaG-BihC-PXpOu3 Finally lets our LVM [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo lvresize -r -L +200M /dev/myvgName/mylvmName Size of logical volume myvgName/mylvmName changed from 500.00 MiB (125 extents) to 700.00 MiB (175 extents). Logical volume myvgName/mylvmName successfully resized. resize2fs 1.45.6 (20-Mar-2020) Filesystem at /dev/mapper/myvgName-mylvmName is mounted on /mylvmpnt; on-line resizing required old_desc_blocks = 4, new_desc_blocks = 6 The filesystem on /dev/mapper/myvgName-mylvmName is now 716800 (1k) blocks long. Create LVM Snapshot LVM snapshots create an exact copy of an existing logical volume. They are useful for backups, application testing, and deploying VMs (Virtual Machines). The original state of the snapshot is kept as the block map.\nSnapshots only use space for storing deltas:\n When the original logical volume changes, original data blocks are copied to the snapshot. If data is added to snapshot, it is stored only there.  [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo lvcreate -l 128 -s -n mysnap /dev/myvgName/mylvmName Logical volume \u0026#34;mysnap\u0026#34; created. check snap\n[s0x45ker--_(+_+)_--SysAdmin ~]$ df -Th | grep mysnap /dev/mapper/myvgName-mysnap ext4 670M 2.5M 631M 1% /mnt Delete Snapshot or Any LVM [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo lvremove /dev/myvgName/mysnap Do you really want to remove active logical volume myvgName/mysnap? [y/n]: y Logical volume \u0026#34;mysnap\u0026#34; successfully removed ","date":"April 18, 2021","hero":"/posts/linux-sys-admin/advanced-storage-managment/logical-volume-manager/images/night.jpg","permalink":"https://henzelmoras.github.io/posts/linux-sys-admin/advanced-storage-managment/logical-volume-manager/","summary":"About Logical Volume Manager One or more physical volumes (disk partitions) are grouped together into a volume group. Then, the volume group is subdivided into logical volumes, which mimic to the system nominal physical disk partitions and can be formatted to contain mountable filesystems.\nLogical volumes are created by putting all the devices into a large pool of disk space (the volume group), and then allocating space from the pool to create a logical volume.","tags":null,"title":"Logical Volume Manager"},{"categories":null,"contents":"Filesystem Quotas Linux can use and enforce quotas on filesystems. Disk quotas allow administrators to control the maximum space particular users (or groups) are allowed. Considerable flexibility is allowed and quotas can be assigned on a per filesystem basis. Protection is provided against a subset of users exhausting collective resources.\nUtilities  quotacheck  quotacheck generates and updates quota accounting files.\n  quotaon  quotaon enables quota accounting.\n  quotaoff  quotaoff disables quota accounting.\n  edquota  edquota used for editing user or group quotas.\n  quota  quota reports on usage and limits.\n Quota operations require the existence of the filesÂ aquota.userÂ andÂ aquota.groupÂ in the root directory of the filesystem using quotas.\nQuotas may be enabled or disabled on a per-filesystem basis. In addition, Linux supports the use of quotas based on user and group IDs.\nDifferent filesystem types may have additional quota-related utilities, such asÂ xfs_quota.\nSteps  Mount the filesystem with user and/or group quota options:Add theÂ usrquotaÂ and/orÂ grpquotaÂ options to the filesystems entry inÂ /etc/fstabRemount the filesystem (or mount it if new) RunÂ quotacheckÂ on the filesystem to set up quotas Enable quotas on the filesystem Set quotas with theÂ edquotaÂ program.  1. Userquota in Fstab in this example we will use a file as disk and add quota settings within /etc/fstab\n[s0x45ekr--_(+_+)_--Sysadmin ~]$ dd if=/dev/zero of=imagefile bs=1M count=1024 1024+0 records in 1024+0 records out 1073741824 bytes (1.1 GB, 1.0 GiB) copied, 1.0488 s, 1.0 GB/s [s0x45ekr--_(+_+)_--Sysadmin ~]$ mkfs.ext4 imagefile mke2fs 1.45.6 (20-Mar-2020) Discarding device blocks: done Creating filesystem with 262144 4k blocks and 65536 inodes Filesystem UUID: e9b2993f-b882-404b-8692-d411c8e1adb6 Superblock backups stored on blocks: 32768, 98304, 163840, 229376 Allocating group tables: done Writing inode tables: done Creating journal (8192 blocks): done Writing superblocks and filesystem accounting information: done [s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo nano /etc/fstab # # /etc/fstab # Created by anaconda on Thu Nov 12 19:37:28 2020 # # Accessible filesystems, by reference, are maintained under \u0026#39;/dev/disk/\u0026#39;. # See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info. # # After editing this file, run \u0026#39;systemctl daemon-reload\u0026#39; to update systemd # units generated from this file. # /dev/mapper/cl-root / xfs defaults 0 0 UUID=03f520f5-2aec-411c-a15b-3e2f62ffc37c /boot ext4 defaults 1 2 /dev/mapper/cl-swap swap swap defaults 0 0 /home/s0x45ker/imagefile /mnt ext4 loop,usrquota 1 2 finally mount em\n[s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo mount -a [s0x45ekr--_(+_+)_--Sysadmin ~]$ df -Th | grep mnt /dev/loop0 ext4 976M 2.6M 907M 1% /mnt 2. Setup quota [s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo quotacheck -u /mnt/ 3. Enable quota [s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo quotaon -u /mnt/ might need to change ownership so that we can exhust quotas as that user\n[s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo quotaon -u /mnt/ [s0x45ekr--_(+_+)_--Sysadmin ~]$ ls -al / | grep mnt drwxr-xr-x. 3 s0x45ker s0x45ker 4096 Apr 18 16:33 mnt 4. Set Quota soft limit : 200 which can be exceeded but will show a warning\nhard limt : 600 which will stop the operation if size exceeds\n[s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo edquota -u s0x45ker Disk quotas for user s0x45ker (uid 1001): Filesystem blocks soft hard inodes soft hard /dev/loop0 600 200 600 4 0 0 ok so now lets put our user s0x45ker quotas to the test\n[s0x45ekr--_(+_+)_--Sysadmin /mnt]$ dd if=/dev/zero of=file bs=1024 count=200 loop0: warning, user block quota exceeded. 200+0 records in 200+0 records out 204800 bytes (205 kB, 200 KiB) copied, 0.00263448 s, 77.7 MB/s [s0x45ekr--_(+_+)_--Sysadmin /mnt]$ sudo quota s0x45ker Disk quotas for user s0x45ker (uid 1001): Filesystem blocks quota limit grace files quota limit grace /dev/loop0 204* 200 600 6days 2 0 0 [s0x45ekr--_(+_+)_--Sysadmin /mnt]$ dd if=/dev/zero of=file1 bs=1024 count=200 200+0 records in 200+0 records out 204800 bytes (205 kB, 200 KiB) copied, 0.00249903 s, 82.0 MB/s [s0x45ekr--_(+_+)_--Sysadmin /mnt]$ sudo quota s0x45ker Disk quotas for user s0x45ker (uid 1001): Filesystem blocks quota limit grace files quota limit grace /dev/loop0 404* 200 600 6days 3 0 0 [s0x45ekr--_(+_+)_--Sysadmin /mnt]$ dd if=/dev/zero of=file2 bs=1024 count=200 loop0: write failed, user block limit reached. dd: error writing \u0026#39;file2\u0026#39;: Disk quota exceeded 197+0 records in 196+0 records out 200704 bytes (201 kB, 196 KiB) copied, 0.000840477 s, 239 MB/s as u can see the file operatition stops when it exceeds hard limit\n","date":"April 18, 2021","hero":"/posts/linux-sys-admin/advanced-storage-managment/quotas/images/work.jpg","permalink":"https://henzelmoras.github.io/posts/linux-sys-admin/advanced-storage-managment/quotas/","summary":"Filesystem Quotas Linux can use and enforce quotas on filesystems. Disk quotas allow administrators to control the maximum space particular users (or groups) are allowed. Considerable flexibility is allowed and quotas can be assigned on a per filesystem basis. Protection is provided against a subset of users exhausting collective resources.\nUtilities  quotacheck  quotacheck generates and updates quota accounting files.\n  quotaon  quotaon enables quota accounting.\n  quotaoff  quotaoff disables quota accounting.","tags":null,"title":"Quotas"},{"categories":null,"contents":"About RAID Three essential features of RAID are:\n mirroring: writing the same data to more than one disk striping: splitting of data to more than one disk parity: extra data is stored to allow problem detection and repair, yielding fault tolerance.  Thus, use of RAID can improve both performance and reliability.\nmdadmÂ is used to create and manage RAID devices.\nOnce created, the array name,Â /dev/mdX, can be used just like any other device, such asÂ /dev/sdb1.\nRAID Levels   RAID 0  RAID 0 uses only striping. Data is spread across multiple disks. However, in spite of the name, there is no redundancy and there is no stability or recovery capabilities. In fact, if any disk fails, data will be lost. But performance can be improved significantly because of parallelization of I/O tasks.\n   RAID 1 RAID 1 uses only mirroring; each disk has a duplicate. This is good for recovery. At least two disks are required.\n   RAID 5 RAID 1 uses only mirroring; each disk has a duplicate. This is good for recovery. At least two disks are required.\n   RAID 6 RAID 6 has striped disks with dual parity; it can handle loss of two disks, and requires at least 4 disks. Because RAID 5 can impose significant stress on disks, which can lead to failures during recovery procedures, RAID 6 has become more important.\n   RAID 10  RAID 10 is a mirrored and striped data set. At least 4 drives are needed.  As a general rule, adding more disks improves performance.\nCreating RAID Partitions we will make use of the lvm partition we created last tutorial or if u want use any other disk drives\nlast tutorial we only created one lvm lets create one more since RAID 1 requires two disk drives\n[s0x45ker--_(+_+)_--SysAdmin ~]$ sudo lvcreate -L 200M -n lvmp2 myvgName Logical volume \u0026#34;lvmp2\u0026#34; created. [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo lvcreate -L 200M -n lvmp3 myvgName Logical volume \u0026#34;lvmp3\u0026#34; created. lets list them for better view\n[s0x45ker--_(+_+)_--SysAdmin ~]$ sudo lvdisplay | grep lvm LV Path /dev/myvgName/mylvmName LV Name mylvmName LV Path /dev/myvgName/lvmp2 LV Name lvmp2 lets create using mdadm make sure to umount before creating\n[s0x45ker--_(+_+)_--SysAdmin ~]$ sudo mdadm -C /dev/md0 --level=1 --raid-disks=2 /dev/myvgName/mylvmName /dev/myvgName/lvmp2 mdadm: /dev/myvgName/mylvmName appears to contain an ext2fs file system size=716800K mtime=Sat Apr 17 14:54:37 2021 mdadm: Note: this array has metadata at the start and may not be suitable as a boot device. If you plan to store \u0026#39;/boot\u0026#39; on this device please ensure that your boot-loader understands md/v1.x metadata, or use --metadata=0.90 mdadm: largest drive (/dev/myvgName/mylvmName) exceeds size (203776K) by more than 1% Continue creating array? y mdadm: Defaulting to version 1.2 metadata mdadm: array /dev/md0 started. Filesystem on Disk /dev/md0 [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo mkfs.ext4 /dev/md0 mke2fs 1.45.6 (20-Mar-2020) Creating filesystem with 203776 1k blocks and 51000 inodes Filesystem UUID: a10242e4-ce80-44d7-afea-cce0ab0a1c0a Superblock backups stored on blocks: 8193, 24577, 40961, 57345, 73729 Allocating group tables: done Writing inode tables: done Creating journal (4096 blocks): done Writing superblocks and filesystem accounting information: 0/done Mount RAID [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo mount /dev/md0 /mnt/ within /etc/fstab\n[s0x45ker--_(+_+)_--SysAdmin ~]$ sudo nano /etc/fstab GNU nano 2.9.8 /etc/fstab # # /etc/fstab # Created by anaconda on Thu Nov 12 19:37:28 2020 # # Accessible filesystems, by reference, are maintained under \u0026#39;/dev/disk/\u0026#39;. # See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info. # # After editing this file, run \u0026#39;systemctl daemon-reload\u0026#39; to update systemd # units generated from this file. # /dev/mapper/cl-root / xfs defaults 0 0 UUID=03f520f5-2aec-411c-a15b-3e2f62ffc37c /boot ext4 defaults 1 2 /dev/mapper/cl-swap swap swap defaults 0 0 /dev/myvgName/mylvmName /mylvmpnt ext4 defaults 0 0 /dev/md0 /mnt ext4 defaults 0 0 RAID config in /etc/mdadm.conf\n[s0x45ker--_(+_+)_--SysAdmin ~]$ sudo bash -c \u0026#34;mdadm --detail --scan \u0026gt;\u0026gt; /etc/mdadm.conf\u0026#34; Monitor RAID Status [s0x45ker--_(+_+)_--SysAdmin ~]$ cat /proc/mdstat Personalities : [raid1] md0 : active raid1 dm-3[1] dm-2[0] 203776 blocks super 1.2 [2/2] [UU] unused devices: \u0026lt;none\u0026gt; RAID Hot Spares lets remove are fake faulty drive lvm2\n[s0x45ker--_(+_+)_--SysAdmin ~]$ sudo mdadm --remove /dev/md0 /dev/myvgName/lvmp2 mdadm: hot removed /dev/myvgName/lvmp2 from /dev/md0 add a new one\n[s0x45ker--_(+_+)_--SysAdmin ~]$ sudo mdadm --add /dev/md0 /dev/myvgName/lvmp3 mdadm: added /dev/myvgName/lvmp3 lets check spare\n[s0x45ker--_(+_+)_--SysAdmin ~]$ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 21.3G 0 disk â”œâ”€sda1 8:1 0 1G 0 part /boot â””â”€sda2 8:2 0 20.3G 0 part â”œâ”€cl-root 253:0 0 18.3G 0 lvm / â””â”€cl-swap 253:1 0 2.1G 0 lvm [SWAP] sdb 8:16 0 2G 0 disk â”œâ”€sdb1 8:17 0 256M 0 part â”‚ â””â”€myvgName-mylvmName 253:2 0 700M 0 lvm â”‚ â””â”€md0 9:0 0 199M 0 raid1 â”œâ”€sdb2 8:18 0 256M 0 part â”‚ â””â”€myvgName-mylvmName 253:2 0 700M 0 lvm â”‚ â””â”€md0 9:0 0 199M 0 raid1 â””â”€sdb3 8:19 0 1.5G 0 part â”œâ”€myvgName-mylvmName 253:2 0 700M 0 lvm â”‚ â””â”€md0 9:0 0 199M 0 raid1 â”œâ”€myvgName-lvmp2 253:3 0 200M 0 lvm â””â”€myvgName-lvmp3 253:4 0 200M 0 lvm â””â”€md0 9:0 0 199M 0 raid1 RAID Monitoring we can also use theÂ mdmonitorÂ service by editingÂ /etc/mdadm.confÂ and adding a line like:\nMAILADDR admin@gmail.com\nso that it notifies you with email sent toÂ admin@gmail.comÂ when a problem occurs with a RAID device, such as when any of the arrays fail to start or fall into a degraded state. You turn it on with:\n$ sudo systemctl start mdmonitor\nand make sure it starts at boot with:\n$ sudo systemctl enable mdmonitor\nðŸ’¡ On Ubuntu systems, the service is calledÂ mdadmÂ rather thanÂ mdmonitor.\n","date":"April 18, 2021","hero":"/posts/linux-sys-admin/advanced-storage-managment/raid/images/gun.jpg","permalink":"https://henzelmoras.github.io/posts/linux-sys-admin/advanced-storage-managment/raid/","summary":"About RAID Three essential features of RAID are:\n mirroring: writing the same data to more than one disk striping: splitting of data to more than one disk parity: extra data is stored to allow problem detection and repair, yielding fault tolerance.  Thus, use of RAID can improve both performance and reliability.\nmdadmÂ is used to create and manage RAID devices.\nOnce created, the array name,Â /dev/mdX, can be used just like any other device, such asÂ /dev/sdb1.","tags":null,"title":"RAID"},{"categories":null,"contents":"About Swap Linux employs a virtual memory system, in which the operating system can function as if it had more memory than it really does. This kind of memory overcommission functions in two ways:\n Many programs do not actually use all the memory they are given permission to use. Sometimes, this is because child processes inherit a copy of the parent\u0026rsquo;s memory regions utilizing a COW (Copy On Write) technique, in which the child only obtains a unique copy (on a page-by-page basis) when there is a change. When memory pressure becomes important, less active memory regions may be swapped out to disk, to be recalled only when needed again.  Such swapping is usually done to one or more dedicated partitions or files; Linux permits multiple swap areas, so the needs can be adjusted dynamically. Each area has a priority, and lower priority areas are not used until higher priority areas are filled.\nIn most situations, the recommended swap size is the total RAM on the system. You can see what your system is currently using for swap areas by looking atÂ /proc/swapsÂ and getting basic memory statistics withÂ free:\ncat /proc/swaps\nfree -m\nThe only commands involving swap are:\n mkswap: format a swap partition or file swapon: activate a swap partition or file swapoff: deactivate a swap partition or file.  At any given time, most memory is in use for caching file contents to prevent actually going to the disk any more than necessary, or in a sub-optimal order or timing. Such pages of memory are never swapped out as the backing store is the files themselves, so writing out a swap would be pointless; instead, dirty pages (memory containing updated file contents that no longer reflect the stored data) are flushed out to disk.\nIt is also worth pointing out that in Linux memory used by the kernel itself, as opposed to application memory, isÂ never swapped out, in distinction to some other operating systems.\nManaging Swap [s0x45ekr--_(+_+)_--Sysadmin ~]$ cat /proc/swaps Filename\tType\tSize\tUsed\tPriority /dev/dm-1 partition\t2166780\t93184\t-2 File As Swap(mkswap) we can also use disk partitions as swap\n[s0x45ekr--_(+_+)_--Sysadmin ~]$ dd if=/dev/zero of=swapfile bs=1M count=1024 1024+0 records in 1024+0 records out 1073741824 bytes (1.1 GB, 1.0 GiB) copied, 1.05868 s, 1.0 GB/s [s0x45ekr--_(+_+)_--Sysadmin ~]$ ls | grep swapfile swapfile file permissions : read,write\nuser and group : root\n[s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo chown root:root swapfile [s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo chmod 600 swapfile [s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo mkswap swapfile mkswap: imagefile: warning: wiping old swap signature. Setting up swapspace version 1, size = 1024 MiB (1073737728 bytes) no label, UUID=e96df880-5122-45bf-853e-d7c321818e04 Turn on Swap [s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo swapon swapfile check if it exists\n[s0x45ekr--_(+_+)_--Sysadmin ~]$ cat /proc/swaps Filename\tType\tSize\tUsedPriority /dev/dm-1 partition\t2166780\t157184\t-2 /home/s0x45ker/swapfile file\t1048572\t0\t-3 Turn off Swap [s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo swapoff swapfile [s0x45ekr--_(+_+)_--Sysadmin ~]$ cat /proc/swaps Filename\tType\tSize\tUsedPriority /dev/dm-1 partition\t2166780\t156852\t-2 finally delete the imagefile after use\n[s0x45ekr--_(+_+)_--Sysadmin ~]$ sudo rm swapfile [s0x45ekr--_(+_+)_--Sysadmin ~]$ ls swapfile ls: cannot access \u0026#39;imagfile\u0026#39;: No such file or directory ","date":"April 18, 2021","hero":"/posts/linux-sys-admin/advanced-storage-managment/swap/images/thugh.png","permalink":"https://henzelmoras.github.io/posts/linux-sys-admin/advanced-storage-managment/swap/","summary":"About Swap Linux employs a virtual memory system, in which the operating system can function as if it had more memory than it really does. This kind of memory overcommission functions in two ways:\n Many programs do not actually use all the memory they are given permission to use. Sometimes, this is because child processes inherit a copy of the parent\u0026rsquo;s memory regions utilizing a COW (Copy On Write) technique, in which the child only obtains a unique copy (on a page-by-page basis) when there is a change.","tags":null,"title":"swap"},{"categories":null,"contents":"How to many utilities are available to partition disks , we will be using fdisk to make partitions on disk.\n# list disks [s0x45ker--_(+_+)_--SysAdmin ~]$ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 21.3G 0 disk â”œâ”€sda1 8:1 0 1G 0 part /boot â””â”€sda2 8:2 0 20.3G 0 part â”œâ”€cl-root 253:0 0 18.3G 0 lvm / â””â”€cl-swap 253:1 0 2.1G 0 lvm [SWAP] sdb 8:16 0 2G 0 disk sr0 11:0 1 1024M 0 rom sr1 11:1 1 1024M 0 rom we will be using /dev/sdb in this tutorial\n# using fdisk [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo fdisk /dev/sdb Welcome to fdisk (util-linux 2.32.1). Changes will remain in memory only, until you decide to write them. Be careful before using the write command. Device does not contain a recognized partition table. Created a new DOS disklabel with disk identifier 0x5b1cda85. # type m to list options Command (m for help): m Help: DOS (MBR) a toggle a bootable flag b edit nested BSD disklabel c toggle the dos compatibility flag Generic d delete a partition F list free unpartitioned space l list known partition types n add a new partition p print the partition table t change a partition type v verify the partition table i print information about a partition Misc m print this menu u change display/entry units x extra functionality (experts only) Script I load disk layout from sfdisk script file O dump disk layout to sfdisk script file Save \u0026amp; Exit w write table to disk and exit q quit without saving changes Create a new label g create a new empty GPT partition table G create a new empty SGI (IRIX) partition table o create a new empty DOS partition table s create a new empty Sun partition table Create Partitions create 3 new primary partitions\nCommand (m for help): n Partition type p primary (0 primary, 0 extended, 4 free) e extended (container for logical partitions) Select (default p): p Partition number (1-4, default 1): First sector (2048-4194303, default 2048): Last sector, +sectors or +size{K,M,G,T,P} (2048-4194303, default 4194303): +256M Created a new partition 1 of type \u0026#39;Linux\u0026#39; and of size 256 MiB. Command (m for help): n Partition type p primary (1 primary, 0 extended, 3 free) e extended (container for logical partitions) Select (default p): p Partition number (2-4, default 2): First sector (526336-4194303, default 526336): Last sector, +sectors or +size{K,M,G,T,P} (526336-4194303, default 4194303): +256M Created a new partition 2 of type \u0026#39;Linux\u0026#39; and of size 256 MiB. Command (m for help): n Partition type p primary (2 primary, 0 extended, 2 free) e extended (container for logical partitions) Select (default p): p Partition number (3,4, default 3): First sector (1050624-4194303, default 1050624): Last sector, +sectors or +size{K,M,G,T,P} (1050624-4194303, default 4194303): Created a new partition 3 of type \u0026#39;Linux\u0026#39; and of size 1.5 GiB. List partition Command (m for help): p Disk /dev/sdb: 2 GiB, 2147483648 bytes, 4194304 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x5b1cda85 Device Boot Start End Sectors Size Id Type /dev/sdb1 2048 526335 524288 256M 83 Linux /dev/sdb2 526336 1050623 524288 256M 83 Linux /dev/sdb3 1050624 4194303 3143680 1.5G 83 Linux Write to disk confirm the settings by writting to disk\nCommand (m for help): w The partition table has been altered. Calling ioctl() to re-read partition table. Syncing disks. Review changes lets check our changes\n[s0x45ker--_(+_+)_--SysAdmin ~]$ lsblk | grep sdb* sda 8:0 0 21.3G 0 disk â”œâ”€sda1 8:1 0 1G 0 part /boot â””â”€sda2 8:2 0 20.3G 0 part sdb 8:16 0 2G 0 disk â”œâ”€sdb1 8:17 0 256M 0 part â”œâ”€sdb2 8:18 0 256M 0 part â””â”€sdb3 8:19 0 1.5G 0 part Place a Filesystem on Disk lets put filesystem on our newly created partitions\ns0x45ker--_(+_+)_--SysAdmin ~]$ sudo mkfs.ext4 /dev/sdb1 mke2fs 1.45.6 (20-Mar-2020) Creating filesystem with 262144 1k blocks and 65536 inodes Filesystem UUID: 68ea7cfb-7d8d-4fb9-a40d-6c16ff282367 Superblock backups stored on blocks: 8193, 24577, 40961, 57345, 73729, 204801, 221185 Allocating group tables: done Writing inode tables: done Creating journal (8192 blocks): done Writing superblocks and filesystem accounting information: done [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo mkfs.ext4 /dev/sdb2 mke2fs 1.45.6 (20-Mar-2020) Creating filesystem with 262144 1k blocks and 65536 inodes Filesystem UUID: 0159b426-cea0-40c0-85d4-670be5da567a Superblock backups stored on blocks: 8193, 24577, 40961, 57345, 73729, 204801, 221185 Allocating group tables: done Writing inode tables: done Creating journal (8192 blocks): done Writing superblocks and filesystem accounting information: done [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo mkfs.ext4 /dev/sdb3 mke2fs 1.45.6 (20-Mar-2020) Creating filesystem with 392960 4k blocks and 98304 inodes Filesystem UUID: 6fbbcc36-35bf-4959-b60f-b041b3eb09d6 Superblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912 Allocating group tables: done Writing inode tables: done Creating journal (8192 blocks): done Writing superblocks and filesystem accounting information: don Creating Mount Points lets create mount points [s0x45ker--_(+_+)_--SysAdmin ~]$ mkdir mnt1 mnt2 mnt3 Mount partition lets mount them\n[s0x45ker--_(+_+)_--SysAdmin ~]$ sudo mount /dev/sdb1 mnt1 [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo mount /dev/sdb2 mnt2 [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo mount /dev/sdb3 mnt3 Check Mount lets check whether they were mounted\n[s0x45ker--_(+_+)_--SysAdmin ~]$ df -Th | grep \u0026#34;mnt*\u0026#34; /dev/sdb1 ext4 240M 2.1M 222M 1% /home/s0x45ker/mnt1 /dev/sdb2 ext4 240M 2.1M 222M 1% /home/s0x45ker/mnt2 /dev/sdb3 ext4 1.5G 4.5M 1.4G 1% /home/s0x45ker/mnt3 Unmount partition unmount after using them\n[s0x45ker--_(+_+)_--SysAdmin ~]$ sudo umount mnt1 mnt2 mnt3 Delete mount dir delete the mount points\n[s0x45ker--_(+_+)_--SysAdmin ~]$ rmdir mnt* Rechcek [s0x45ker--_(+_+)_--SysAdmin ~]$ df -Th | grep \u0026#34;mnt*\u0026#34; [s0x45ker--_(+_+)_--SysAdmin ~]$ ","date":"April 17, 2021","hero":"/posts/linux-sys-admin/basic-storage-management/disk-partition/images/tiny.jpg","permalink":"https://henzelmoras.github.io/posts/linux-sys-admin/basic-storage-management/disk-partition/","summary":"How to many utilities are available to partition disks , we will be using fdisk to make partitions on disk.\n# list disks [s0x45ker--_(+_+)_--SysAdmin ~]$ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 21.3G 0 disk â”œâ”€sda1 8:1 0 1G 0 part /boot â””â”€sda2 8:2 0 20.3G 0 part â”œâ”€cl-root 253:0 0 18.3G 0 lvm / â””â”€cl-swap 253:1 0 2.1G 0 lvm [SWAP] sdb 8:16 0 2G 0 disk sr0 11:0 1 1024M 0 rom sr1 11:1 1 1024M 0 rom we will be using /dev/sdb in this tutorial","tags":null,"title":"Disk Partition"},{"categories":null,"contents":"SATA (Serial Advanced TechnologyÂ Attachment) SATA disks were designed to replace the old IDE drives. They offer a smaller cable size (7 pins), native hot swapping, and faster and more efficient data transfer. They are seen as SCSI devices.\nSCSI (Small Computer Systems Interface) SCSI disks range from narrow (8 bit bus) to wide (16 bit bus), with a transfer rate between 5 MB per second (narrow, standard SCSI) and 160 MB per second (Ultra-Wide SCSI-3). Most PCs use single-ended or differential SCSI drives. Unfortunately, the two types are not compatible with each other. Fortunately, the two types of devices may coexist on the same controller. Single-ended devices may host up to 7 devices, and use a maximum cable length of about 6 meters. Differential controllers may host up to 15 devices and have a maximum cable length of about 12 meters.\nSAS (Serial Attached SCSI) They use a newer point-to-point protocol, and have a better performance than SATA disks.\nUSB (Universal Serial Bus) These include flash drives and floppies. And are seen as SCSI devices.\nSSD (SolidÂ State Drives) Modern SSD drives have come down in price, have no moving parts, use less power than drives with rotational media, and have faster transfer speeds. Internal SSDs are even installed with the same form factor and in the same enclosures as conventional drives. SSDs still cost a bit more, but price is decreasing. It is common to have both SSDs and rotational drives in the same machines, with frequently accessed and performance critical data transfers taking place on the SSDs.\nlIDE and EIDE (Integrated Drive Electronics, Enhanced IDE) These are obsolete.\n","date":"April 17, 2021","hero":"/posts/linux-sys-admin/basic-storage-management/disk-types/hero.png","permalink":"https://henzelmoras.github.io/posts/linux-sys-admin/basic-storage-management/disk-types/","summary":"SATA (Serial Advanced TechnologyÂ Attachment) SATA disks were designed to replace the old IDE drives. They offer a smaller cable size (7 pins), native hot swapping, and faster and more efficient data transfer. They are seen as SCSI devices.\nSCSI (Small Computer Systems Interface) SCSI disks range from narrow (8 bit bus) to wide (16 bit bus), with a transfer rate between 5 MB per second (narrow, standard SCSI) and 160 MB per second (Ultra-Wide SCSI-3).","tags":null,"title":"Disk Types"},{"categories":null,"contents":"About we can create Diskpartition using a file as image we can achieve this using \u0026lsquo;dd\u0026rsquo; or \u0026lsquo;losetup\u0026rsquo;\nUsing: \u0026lsquo;dd\u0026rsquo; create a file full of zeros using dd\n[s0x45ker--_(+_+)_--SysAdmin ~]$ dd if=/dev/zero of=imagefile bs=1M count=1024 #create a file full of zeros 1024+0 records in 1024+0 records out 1073741824 bytes (1.1 GB, 1.0 GiB) copied, 0.904085 s, 1.2 GB/s Format Filesystem Type next we must put a filesystem on it Note u can create different filesystem formats 'mkfs.\u0026lt;type\u0026gt;\n[s0x45ker--_(+_+)_--SysAdmin ~]$ mkfs.ext4 imagefile mke2fs 1.45.6 (20-Mar-2020) Discarding device blocks: done Creating filesystem with 262144 4k blocks and 65536 inodes Filesystem UUID: 3ba526cc-875d-4315-ab6a-534fe7ac58ff Superblock backups stored on blocks: 32768, 98304, 163840, 229376 Allocating group tables: done Writing inode tables: done Creating journal (8192 blocks): done Writing superblocks and filesystem accounting information: done Create Mount Point Now lets mount the filesystem, firstly by creating a directory as mointpoint\n[s0x45ker--_(+_+)_--SysAdmin ~]$ mkdir mntpoint # mount the filesystem [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo mount imagefile mntpoint/ # list the mount point [s0x45ker--_(+_+)_--SysAdmin ~]$ df -h | grep mntpoint /dev/loop0 976M 2.6M 907M 1% /home/s0x45ker/mntpoint # unmount the filesystem [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo umount mntpoint/ # returns nothing [s0x45ker--_(+_+)_--SysAdmin ~]$ df -h | grep mntpoint [s0x45ker--_(+_+)_--SysAdmin ~]$ # delete the directory  [s0x45ker--_(+_+)_--SysAdmin ~]$ rmdir mntpoint [s0x45ker--_(+_+)_--SysAdmin ~]$ Using: \u0026lsquo;losetup\u0026rsquo; check man pages of losetup and parted once again, you can reuse imagefile or create another one using \u0026lsquo;dd\u0026rsquo;\nCheck Free Loop Device # display free loop device [s0x45ker--_(+_+)_--SysAdmin ~]$ losetup -f /dev/loop0 Setup Loop # create an imagefile from it [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo losetup /dev/loop0 imagefile Create Partition # make partition label  [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo parted -s /dev/loop0 mklabel msdos # create 3 partitions on the disk [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo parted -s /dev/loop0 unit MB mkpart primary ext4 0 256 Warning: The resulting partition is not properly aligned for best performance: 1s % 2048s != 0s [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo parted -s /dev/loop0 unit MB mkpart primary ext4 256 512 Warning: The resulting partition is not properly aligned for best performance: 500001s % 2048s != 0s [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo parted -s /dev/loop0 unit MB mkpart primary ext4 512 1024 Warning: The resulting partition is not properly aligned for best performance: 1000001s % 2048s != 0s View Partition # view the partitions [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo fdisk -l /dev/loop0 Disk /dev/loop0: 1 GiB, 1073741824 bytes, 2097152 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0xcf49ab35 Device Boot Start End Sectors Size Id Type /dev/loop0p1 1 500000 500000 244.1M 83 Linux /dev/loop0p2 500001 1000000 500000 244.1M 83 Linux /dev/loop0p3 1000001 2000000 1000000 488.3M 83 Linux [s0x45ker--_(+_+)_--SysAdmin ~]$ ls -l /dev/loop0* brw-rw----. 1 root disk 7, 0 Apr 12 21:22 /dev/loop0 brw-rw----. 1 root disk 259, 0 Apr 12 21:22 /dev/loop0p1 brw-rw----. 1 root disk 259, 1 Apr 12 21:22 /dev/loop0p2 brw-rw----. 1 root disk 259, 2 Apr 12 21:22 /dev/loop0p3 Place Filesystem # put filesystem on partitions [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo mkfs.ext4 /dev/loop0p1 mke2fs 1.45.6 (20-Mar-2020) Discarding device blocks: done Creating filesystem with 250000 1k blocks and 62744 inodes Filesystem UUID: 3b8ebc72-3a3f-46d3-9989-03f24184d248 Superblock backups stored on blocks: 8193, 24577, 40961, 57345, 73729, 204801, 221185 Allocating group tables: done Writing inode tables: done Creating journal (4096 blocks): done Writing superblocks and filesystem accounting information: done [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo mkfs.ext4 /dev/loop0p2 mke2fs 1.45.6 (20-Mar-2020) Discarding device blocks: done Creating filesystem with 250000 1k blocks and 62744 inodes Filesystem UUID: b6f68d7d-7aac-4bd5-86de-b40807f44a74 Superblock backups stored on blocks: 8193, 24577, 40961, 57345, 73729, 204801, 221185 Allocating group tables: done Writing inode tables: done Creating journal (4096 blocks): done Writing superblocks and filesystem accounting information: done [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo mkfs.ext4 /dev/loop0p3 mke2fs 1.45.6 (20-Mar-2020) Discarding device blocks: done Creating filesystem with 499713 1k blocks and 125416 inodes Filesystem UUID: 7029e10e-db19-4328-bb0b-c2162a2d2d7b Superblock backups stored on blocks: 8193, 24577, 40961, 57345, 73729, 204801, 221185, 401409 Allocating group tables: done Writing inode tables: done Creating journal (8192 blocks): done Writing superblocks and filesystem accounting information: done Create Mountpoint # creating directories for mounting [s0x45ker--_(+_+)_--SysAdmin ~]$ mkdir mnt1 mnt2 mnt3 # mount the filesystem on repective directories [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo mount /dev/loop0p1 mnt1 [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo mount /dev/loop0p2 mnt2 [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo mount /dev/loop0p3 mnt3 # check wether it exists [s0x45ker--_(+_+)_--SysAdmin ~]$ df -Th | grep \u0026#34;/dev/loop0*\u0026#34; /dev/loop0p1 ext4 233M 2.1M 215M 1% /home/s0x45ker/mnt1 /dev/loop0p2 ext4 233M 2.1M 215M 1% /home/s0x45ker/mnt2 /dev/loop0p3 ext4 465M 2.3M 434M 1% /home/s0x45ker/mnt3 Delete and Remove # delete and remove after use [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo umount mnt1 mnt2 mnt3 [s0x45ker--_(+_+)_--SysAdmin ~]$ rmdir mnt* [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo losetup -d /dev/loop0 ","date":"April 17, 2021","hero":"/posts/linux-sys-admin/basic-storage-management/file-as-disk/images/juice.jpg","permalink":"https://henzelmoras.github.io/posts/linux-sys-admin/basic-storage-management/file-as-disk/","summary":"About we can create Diskpartition using a file as image we can achieve this using \u0026lsquo;dd\u0026rsquo; or \u0026lsquo;losetup\u0026rsquo;\nUsing: \u0026lsquo;dd\u0026rsquo; create a file full of zeros using dd\n[s0x45ker--_(+_+)_--SysAdmin ~]$ dd if=/dev/zero of=imagefile bs=1M count=1024 #create a file full of zeros 1024+0 records in 1024+0 records out 1073741824 bytes (1.1 GB, 1.0 GiB) copied, 0.904085 s, 1.2 GB/s Format Filesystem Type next we must put a filesystem on it Note u can create different filesystem formats 'mkfs.","tags":null,"title":"File As Disk"},{"categories":null,"contents":"Mount The mount program allows attaching at any point in the tree structure; umount allows detaching them.\nThe mount point is the directory where the filesystem is attached. It must exist before mount can use it;Â mkdirÂ can be used to create an empty directory. If a pre-existing directory is used and it contains files prior to being used as a mount point, they will be hidden after mounting. These files are not deleted and will again be visible when the filesystem is unmounted.\nBy default, only the superuser can mount and unmount filesystems.\nEach filesystem is mounted under a specific directory, as in:\n$ sudo mount UUID=26d58ee2-9d20-4dc7-b6ab-aa87c3cfb69a /home\nUUIDs are unique identifiers\n$ sudo mount -t ext /dev/sdb4 /home\n Mounts an ext4 filesystem Usually not necessary to specify the type with theÂ tÂ option The filesystem is located on a specific partition of a hard drive (/dev/sdb4) The filesystem is mounted at the positionÂ /homeÂ in the current directory tree Any files residing in the originalÂ /homeÂ directory are hidden until the partition is unmounted.  mount all filesystems mentioned in /etc/fstab and many filesystem specific\nmount -a which remounts a filesystem with a read-only attribute.\nsudo mount -o remount,ro /fs to see more options\nmount â€”help displays currently mounted filesystems\nmount mounting network filesystems:\nmount -t nfs \u0026lt;IP\u0026gt;:/NameOfShare /mnt/my_mounted_nfs or in /etc/fstab. Put the following line in /etc/fstab to mount on boot or with mount -a:\nmyserver.com:/shdir /mnt/shdir nfs rsize=8192,wsize=8192,timeo=14,intr 0 0 Umount $ umount [device-file | mount-point] Below are some examples of how to unmount a filesystem:\n  Unmount theÂ /homeÂ filesystem:\n$ sudo umount /home   Unmount theÂ /dev/sda3Â device:\n$ sudo umount /dev/sda3   Note that the command to unmount a filesystem is umount (not unmount!).\nThe most common error encountered when unmounting a filesystem is trying to do this on a filesystem currently in use; i.e., there are current applications using files or other entries in the filesystem.\nThis can be as simple as having a terminal window open in a directory on the mounted filesystem. Just usingÂ cdÂ in that window, or killing it, will get rid of the**device is busy**Â error and allow unmounting.\nHowever, if there are other processes inducing this error, you must kill them before unmounting the filesystem. You can useÂ **fuser**to find out which users are using the filesystem and kill them (be careful with this, you may also want to warn users first). You can also useÂ **lsof**Â (\u0026quot;list open files\u0026quot;) to try and see which files are being used and blocking unmounting.\nmkfs Every filesystem type has a utility for formatting (making) a filesystem on a partition. The generic name for these utilities isÂ mkfs. However, this is just a frontend for filesystem-specific programs, each of which may have particular options.\nThe general format forÂ mkfsÂ is:\n**mkfs [-t fstype] [options] [device-file]** whereÂ [device-file]Â is usually a device name likeÂ /dev/sda3Â orÂ /dev/vg/lvm1.\nThe following two commands are entirely equivalent:\n**$ sudo mkfs -t ext4 /dev/sda10** **$ sudo mkfs.ext4 /dev/sda10** Each filesystem type has its own particular options that can be set when formatting. For example, when creating an ext4 filesystem, one thing to keep in mind are the journalling settings. These include defining the journal file size and whether or not to use an external journal file.\nfstab [s0x45ker--_(+_+)_--SysAdmin ~]$ cat /etc/fstab # # /etc/fstab # Created by anaconda on Thu Nov 12 19:37:28 2020 # # Accessible filesystems, by reference, are maintained under \u0026#39;/dev/disk/\u0026#39;. # See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info. # # After editing this file, run \u0026#39;systemctl daemon-reload\u0026#39; to update systemd # units generated from this file. # /dev/mapper/cl-root / xfs defaults 0 0 UUID=03f520f5-2aec-411c-a15b-3e2f62ffc37c /boot ext4 defaults 1 2 /dev/mapper/cl-swap swap swap defaults 0 0 Each record in theÂ /etc/fstabÂ file contains white space separated files of information about a filesystem to be mounted:\n Device file name, label, or UUIDFor filesystems which do not have a device node, such as tmpfs, proc, and sysfs, this field is just a placeholder; sometimes, you will see the wordÂ noneÂ in that column, or used on the command line. Mount pointThis can also be a placeholder, like for swap, which is not mounted anywhere. fs typeFilesystem type (i.e., ext4, xfs, btrfs, vfat) A comma-separated list of options e.g.(noauto,x-systemd.automount,x-systemd.device-timeout=10,x-systemd.idle-timeout=3) dump frequency (or a 0)This is used by the rarely usedÂ dump -wÂ command. fsck pass number (or 0, meaning do not check state at boot).  Fsck Every filesystem type has a utility designed to check for errors (and hopefully fix any that are found). The generic name for these utilities is fsck. However, this is just a frontend for filesystem-specific programs.\nfsck [-t fstype] [options] [device-file] You can control whether any errors found should be fixed one by one manually with theÂ -rÂ option, or automatically, as best possible, by using theÂ -aÂ option, etc. In addition, each filesystem type may have its own particular options that can be set when checking.\nNote that journalling filesystems are much faster to check than older generation filesystems for two reasons:\n You rarely need to scan the entire partition for errors, as everything but the very last transaction has been logged and confirmed, so it takes almost no time to check. Even if you do check the whole filesystem, newer filesystems have been designed with fast fsck in mind; older filesystems did not think much about this when they were designed as sizes were much smaller.  $ sudo fsck -t ext4 /dev/sda10 or $ sudo fsck.ext4 /dev/sda10 if the filesystem is of a type understood by the operating system, you can almost just do:\nsudo fsck /dev/sda10 and the system will figure out the type by examining the first few bytes on the partition.\nfsck is run automatically after a set number of mounts or a set interval since the last time it was run or after an abnormal shutdown. It should only be run on unmounted filesystems. You can force a check of all mounted filesystems at boot by doing:\n$ sudo touch /forcefsck $ sudo reboot The file /forcefsck will disappear after the successful check. One reason this is a valuable trick is it can do a fsck on the root filesystem, which is hard to do on a running system.\nTo list block devices and their attributes\nblkid [s0x45ker--_(+_+)_--SysAdmin ~]$ sudo blkid /dev/sd* /dev/sda: PTUUID=\u0026#34;efac2304\u0026#34; PTTYPE=\u0026#34;dos\u0026#34; /dev/sda1: UUID=\u0026#34;03f520f5-2aec-411c-a15b-3e2f62ffc37c\u0026#34; BLOCK_SIZE=\u0026#34;4096\u0026#34; TYPE=\u0026#34;ext4\u0026#34; PARTUUID=\u0026#34;efac2304-01\u0026#34; /dev/sda2: UUID=\u0026#34;HkaGdc-0SM4-q58B-GLpF-yBKh-dluM-Zb7psU\u0026#34; TYPE=\u0026#34;LVM2_member\u0026#34; PARTUUID=\u0026#34;efac2304-02\u0026#34; /dev/sdb: PTUUID=\u0026#34;5b1cda85\u0026#34; PTTYPE=\u0026#34;dos\u0026#34; /dev/sdb1: UUID=\u0026#34;68ea7cfb-7d8d-4fb9-a40d-6c16ff282367\u0026#34; BLOCK_SIZE=\u0026#34;1024\u0026#34; TYPE=\u0026#34;ext4\u0026#34; PARTUUID=\u0026#34;5b1cda85-01\u0026#34; /dev/sdb2: UUID=\u0026#34;0159b426-cea0-40c0-85d4-670be5da567a\u0026#34; BLOCK_SIZE=\u0026#34;1024\u0026#34; TYPE=\u0026#34;ext4\u0026#34; PARTUUID=\u0026#34;5b1cda85-02\u0026#34; /dev/sdb3: UUID=\u0026#34;6fbbcc36-35bf-4959-b60f-b041b3eb09d6\u0026#34; BLOCK_SIZE=\u0026#34;4096\u0026#34; TYPE=\u0026#34;ext4\u0026#34; PARTUUID=\u0026#34;5b1cda85-03\u0026#34; lsblk A related utility is lsblk which presents block device information in a tree format, as in the following screenshot.\n[s0x45ker--_(+_+)_--SysAdmin ~]$ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 21.3G 0 disk â”œâ”€sda1 8:1 0 1G 0 part /boot â””â”€sda2 8:2 0 20.3G 0 part â”œâ”€cl-root 253:0 0 18.3G 0 lvm / â””â”€cl-swap 253:1 0 2.1G 0 lvm [SWAP] sdb 8:16 0 2G 0 disk â”œâ”€sdb1 8:17 0 256M 0 part â”œâ”€sdb2 8:18 0 256M 0 part â””â”€sdb3 8:19 0 1.5G 0 part sr0 11:0 1 1024M 0 rom sr1 11:1 1 1024M 0 rom ","date":"April 17, 2021","hero":"/posts/linux-sys-admin/basic-storage-management/interacting-with-disks/images/force.png","permalink":"https://henzelmoras.github.io/posts/linux-sys-admin/basic-storage-management/interacting-with-disks/","summary":"Mount The mount program allows attaching at any point in the tree structure; umount allows detaching them.\nThe mount point is the directory where the filesystem is attached. It must exist before mount can use it;Â mkdirÂ can be used to create an empty directory. If a pre-existing directory is used and it contains files prior to being used as a mount point, they will be hidden after mounting. These files are not deleted and will again be visible when the filesystem is unmounted.","tags":null,"title":"Interacting With Disks"},{"categories":null,"contents":"Disks Disks are divided into partitions. In geometrical terms, these consist of physically contiguous groups of sectors or cylinders. A partition is a physically contiguous region on the disk. There are two partitioning layouts in use:\n MBR (Master Boot Record) GPT (GUID Partition Table).  MBR dates back to the early days of MSDOS.\nThe disk partition table is contained within the disk\u0026rsquo;s Master Boot Record (MBR), and is the 64 bytes following the 446 byte boot record. One partition on a disk may be marked active. When the system boots, that partition is where the MBR looks for items to load.\nRemember that there can be only one extended partition, but that partition may contain a number of logical partitions.\nThe structure of the MBR is defined by an operating system-independent convention. The first 446 bytes are reserved for the program code. They typically hold part of a boot loader program. The next 64 bytes provide space for a partition table of up to four entries. The operating system needs this table for handling the hard disk.\nOn Linux systems, the beginning and ending address in CHS is ignored.\nNote for the curious, there are 2 more bytes at the end of the MBR known as the magic number, signature word, or end of sector marker, which always have the value 0x55AA.\nMBR Disk Partition Table Each entry in the partition table is 16 bytes long, and describes one of the four possible primary partitions. The information for each is:\n Active bit Beginning address in cylinder/head/sectors (CHS) format (ignored by Linux) Partition type code, indicating: xfs, LVM, ntfs, ext4, swap, etc. Ending address in CHS (also ignored by Linux) Start sector, counting linearly from 0 Number of sectors in partition.  Linux only uses the last two fields for addressing, using the linear block addressing (LBA) method.\nGPT Partition Table GPT is on all modern systems and is based on UEFI (Unified Extensible Firmware Interface). By default, it may have up to 128 primary partitions. When using the GPT scheme, there is no need for extended partitions. Partitions can be up to 233 TB in size (with MBR, the limit is just 2TB).\nModern hardware comes with GPT support; MBR support will gradually fade away.\nThe Protective MBR is for backwards compatibility, so UEFI systems can be booted the old way.\nThere are two copies of the GPT header, at the beginning and at the end of the disk, describing metadata:\n List of usable blocks on disk Number of partitions Size of partition entries. Each partition entry has a minimum size of 128 bytes.  Patrition Table editiors\n  fdisk\nfdiskÂ is a menu-driven partition table editor. It is the most standard and one of the most flexible of the partition table editors. As with any other partition table editor, make sure that you either write down the current partition table settings or make a copy of the current settings before making changes.\n  sfdisk\nsfdiskÂ is a non-interactive Linux-based partition editor program, making it useful for scripting. Use theÂ sfdiskÂ tool with care!\n  parted\npartedÂ is the GNU partition manipulation program. It can create, remove, resize, and move partitions (including certain filesystems). The GUI interface to theÂ partedÂ command isÂ gparted.\n  gparted\ngpartedÂ is a widely-used graphical interface toÂ parted.\n  gdisk\ngdiskÂ is used for GPT systems, but can also operate on MBR systems.\n  sgdisk\nsgdisk is a script or command line interface.\n  ","date":"April 17, 2021","hero":"/posts/linux-sys-admin/basic-storage-management/storage-overview/hero.png","permalink":"https://henzelmoras.github.io/posts/linux-sys-admin/basic-storage-management/storage-overview/","summary":"Disks Disks are divided into partitions. In geometrical terms, these consist of physically contiguous groups of sectors or cylinders. A partition is a physically contiguous region on the disk. There are two partitioning layouts in use:\n MBR (Master Boot Record) GPT (GUID Partition Table).  MBR dates back to the early days of MSDOS.\nThe disk partition table is contained within the disk\u0026rsquo;s Master Boot Record (MBR), and is the 64 bytes following the 446 byte boot record.","tags":null,"title":"Storage Overview"},{"categories":null,"contents":"Why Partition? There are multiple reasons as to why it makes sense to divide your system data into multiple partitions, including:\n Separation of user and application data from operating system files Sharing between operating systems and/or machines Security enhancement by imposing different quotas and permissions for different system parts Size concerns; keeping variable and volatile storage isolated from stable Performance enhancement of putting most frequently used data on faster storage media Swap space can be isolated from data and also used for hibernation storage.  Deciding what to partition and how to separate your partitions is cause for thought. The reasons to have distinct partitions include increased granularity of security, quota, settings or size restrictions. You could have distinct partitions to allow for data protection.\nA common partition layout contains a boot partition, a partition for the root filesystem /, a swap partition, and a partition for the /home directory tree.\nKeep in mind that it is more difficult to resize a partition after the fact than during install/creation time. Plan accordingly.\n","date":"April 17, 2021","hero":"/posts/linux-sys-admin/basic-storage-management/why-disk-partition/hero.png","permalink":"https://henzelmoras.github.io/posts/linux-sys-admin/basic-storage-management/why-disk-partition/","summary":"Why Partition? There are multiple reasons as to why it makes sense to divide your system data into multiple partitions, including:\n Separation of user and application data from operating system files Sharing between operating systems and/or machines Security enhancement by imposing different quotas and permissions for different system parts Size concerns; keeping variable and volatile storage isolated from stable Performance enhancement of putting most frequently used data on faster storage media Swap space can be isolated from data and also used for hibernation storage.","tags":null,"title":"Why Disk Partition ?"},{"categories":null,"contents":"Using dd for backup we can use dd or gfdisk\nThe dd program is very useful for making copies of raw disk space. A common joke with `dd' is that is stands for data destroyer, so it should be noted that it\u0026rsquo;s a very dangerous utility.\nwe will use one of the partition we created from earlier posts /dev/sdb1\n**lets create a file within disk than backup the disk and delete the file and restore the disk**\nMount The Disk firstly, lets mount the disk\n[s0x45ker--_(+_+)_--SysAdmin /]$ sudo mount /dev/sdb1 mnt/ Check Mount lets check the mount\n[s0x45ker--_(+_+)_--SysAdmin /]$ df -Th | grep sdb1 /dev/sdb1 ext4 240M 2.1M 222M 1% /mnt or [s0x45ker--_(+_+)_--SysAdmin /]$ lsblk | grep sdb1 â”œâ”€sdb1 8:17 0 256M 0 part /mnt Create file to backup lets create a file within the mount point\n[s0x45ker--_(+_+)_--SysAdmin /mnt]$ sudo dd if=/dev/zero of=imagefile bs=1M count=230 230+0 records in 230+0 records out 241172480 bytes (241 MB, 230 MiB) copied, 0.247848 s, 973 MB/s [s0x45ker--_(+_+)_--SysAdmin /mnt]$ ls imagefile lost+found Disk backup create backup of the disk\n[s0x45ker--_(+_+)_--SysAdmin /]$ sudo dd if=/dev/sdb1 of=backup.sdb1 524288+0 records in 524288+0 records out 268435456 bytes (268 MB, 256 MiB) copied, 1.004 s, 267 MB/s Delete File After Disk Backup lets delete the file\ns0x45ker--_(+_+)_--SysAdmin /]$ sudo rm imagefile [s0x45ker--_(+_+)_--SysAdmin /mnt]$ ls # imagefile no longer exists lost+found Restore Disk Backup lets retsore the backup\nfirstly unmount the disk or it might say imagefile: cannot open imagefile' (No such file or directory)` when restored\n[s0x45ker--_(+_+)_--SysAdmin /]$ cd .. ; sudo umount /mnt \u0026amp;\u0026amp; ls backup.sdb1 bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var restore backup with following command\n[s0x45ker--_(+_+)_--SysAdmin /]$ sudo dd if=backup.sdb1 of=/dev/sdb1 524288+0 records in 524288+0 records out 268435456 bytes (268 MB, 256 MiB) copied, 11.4738 s, 23.4 MB/s View Backup File the file hase been restored\n[s0x45ker--_(+_+)_--SysAdmin /]$ sudo mount /dev/sdb1 mnt/ \u0026amp;\u0026amp; cd /mnt/ ; ls imagefile lost+found we have successfully backedup and restored a disk\n","date":"April 16, 2021","hero":"/posts/linux-sys-admin/basic-storage-management/backup-partition/images/me.jpg","permalink":"https://henzelmoras.github.io/posts/linux-sys-admin/basic-storage-management/backup-partition/","summary":"Using dd for backup we can use dd or gfdisk\nThe dd program is very useful for making copies of raw disk space. A common joke with `dd' is that is stands for data destroyer, so it should be noted that it\u0026rsquo;s a very dangerous utility.\nwe will use one of the partition we created from earlier posts /dev/sdb1\n**lets create a file within disk than backup the disk and delete the file and restore the disk**","tags":null,"title":"Backup Partition"},{"categories":null,"contents":"Application programs read and write files , rather than dealing with physical locations on the actual hardware on which files are stored. Filesystems create a usable format on physical partition.\nFiles and their names are an abstraction camouflaging the physical I/O layer.\nA UNIX-like filesystem uses a tree hierarchy:\n Directories contain files and/or other directories Every path or node is under the root directory.  Multiple filesystems may be (and usually are) merged together into a single tree structure. Linux uses a virtual filesystem layer (VFS) to communicate with the filesystem software.\nLocal filesystems generally reside within a disk partition which can be a physical partition on a disk, or a logical partition controlled by a Logical Volume Manager (LVM). Filesystems can also be of a network nature and their true physical embodiment completely hidden to the local system across the network.\nInodes An inode is a data structure on disk that describes and stores file attributes, including location. Every file is associated with its own inode. The information stored in the inode includes:\n Permissions User and group ownership Size Timestamps (nanosecond)Last access timeLast modification timeChange time.  Data storage in an inode vs data storage in a directory file\nðŸ’¡ File names are not stored in a file\u0026rsquo;s inode, but are instead stored in the directory file. The name of a file is just a property of its inode, which is the more fundamental object.\nAll I/O activity concerning a file usually also involves the file\u0026rsquo;s inode, as information must be updated.\nJournaling Filesystems Journaling filesystems recover from system crashes or ungraceful shutdowns with little or no corruption, and do so very rapidly. While this comes at the price of having some more operations to do, additional enhancements can more than offset the price.\nIn a journaling filesystem, operations are grouped into transactions. A transaction must be completed without error, atomically; otherwise, the filesystem is not changed. A log file is maintained of transactions. When an error occurs, usually only the last transaction needs to be examined.\nLinux supports many filesystem varieties, most with full read and write access, including:\n ext4: Linux native filesystem (and earlier ext2 and ext3) XFS: A high-performance filesystem originally created by SGI JFS: A high-performance filesystem originally created by IBM Windows-natives: FAT12, FAT16, FAT32, VFAT, NTFS Pseudo-filesystems resident only in memory, including proc, sysfs, devfs, debugfs Network filesystems such as NFS, coda, afs etc.  This democratic flexibility has been a large factor in its success. Most filesystems have full read/write access, while a few have read only access.\nCommonly used filesystems include ext4, xfs, btrfs, squashfs, nfs and vfat. A list of currently supported filesystems is atÂ /proc/filesystems.\nSpecial Filesystems Linux widely employs the use of special filesystems for certain tasks. These are particularly useful for accessing various kernel data structures and tuning kernel behavior, or for implementing particular functions. Note that some of these special filesystems have no mount point, such asÂ sockfsÂ orÂ pipefs; this means user applications don\u0026rsquo;t interact with them, but the kernel uses them, taking advantage of VFS layers and code. These special filesystems are really not true filesystems; they are kernel facilities or subsystems that find the filesystem structural abstraction to be a useful way to recognize data and functionality.\nTable: Special Filesystems\n   FILESYSTEM MOUNT POINT PURPOSE     rootfs None During kernel load, provides an empty root directory   hugetlbfs Anywhere Provides extended page access (2 or 4 MB on X86)   bdev None Used for block devices   proc /proc Pseudofilesystem access to many kernel structures and subsystems   sockfs None Used by BSD Sockets   tmpfs Anywhere RAM disk with swapping, re-sizing   shm None Used by System V IPC Shared Memory   pipefs None Used for pipes   binfmt_misc Anywhere Used by various executable formats   devpts /dev/pts Used by Unix98 pseudo-terminals   usbfs /proc/bus/usb Used by USB sub-system for dynamical devices   sysfs /sys Used as a device tree   debugfs /sys/kernel/debug Used for simple debugging file access    ","date":"April 16, 2021","hero":"/posts/linux-sys-admin/linux-virtual-filesystem/images/rainbow.png","permalink":"https://henzelmoras.github.io/posts/linux-sys-admin/linux-virtual-filesystem/","summary":"Application programs read and write files , rather than dealing with physical locations on the actual hardware on which files are stored. Filesystems create a usable format on physical partition.\nFiles and their names are an abstraction camouflaging the physical I/O layer.\nA UNIX-like filesystem uses a tree hierarchy:\n Directories contain files and/or other directories Every path or node is under the root directory.  Multiple filesystems may be (and usually are) merged together into a single tree structure.","tags":null,"title":"Linux Virtual Filesystem"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://henzelmoras.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"}]